Welcome to the Comprehensive Manual of C Language! Whether you're a beginner stepping into the world of programming or an experienced coder familiar with other languages, this manual is designed to equip you with the essential skills and knowledge to master the C programming language.

This manual in the the form of synthetic charts, with examples that encompass main situations leading its readers to a ready to go ability to code. Also, it includes exercises and a reference index of essential reserved words (keywords that we will learn later) in the annexes.

##############################################################################################################################

* Why Learn C?

C is often regarded as the "primitive sea of all programming languages", giving birth to C++, Java, and Python... Unlike high-level languages that offer abstraction from the hardware, C operates closer to the hardware, making it a low-level language. This proximity allows C programmers to have greater control over memory allocation and the ability to interact directly with hardware resources, resulting in more efficient and powerful programming.

Moreover, C is widely used in operating system development due to its ability to interact closely with hardware and manage system resources efficiently. Operating systems, being the bridge between hardware and software, rely heavily on C's features for tasks such as memory management, process scheduling, and device control.

Therefore, learning C not only provides a solid foundation for understanding how computers operate at a fundamental level but also equips programmers with the skills to write efficient and powerful code as drivers, making it an indispensable language in various domains of software development.
------------------------------------------------------------------------------------------------------------------------------

* What is a compiler, and how to use it?

If C allow us to give or receive more naturally instruction to the computer/programs, a compiler act as a translator to make the coding language intelligible to the machine. 

A compiler is a software tool that translates high-level programming languages into machine-readable code, typically in the form of executable files or intermediate code.

GCC (GNU Compiler Collection) is one of the most widely used compilers for C and other programming languages. It is open-source and available for various operating systems, including Windows, macOS, and Linux.

Here's how to use GCC to compile a C program on different operating systems:

Windows: gcc my_program.c -o my_program.exe
This command compiles my_program.c and generates an executable file named my_program.exe.

macOS: gcc my_program.c -o my_program
GCC is usually pre-installed on macOS. You can open the Terminal and navigate to the directory containing your C source code, that is to say the my_program.c file. This command compiles my_program.c and generates an executable file named my_program.

Linux (The best OS, yes I love Linux): gcc my_program.c -o my_program
In all cases, -o option is used to specify the name of the output executable file. If not provided, GCC generates an executable file named a.out by default.

Once the program is compiled, you can run the executable file to execute the program on your operating system. For example, on Windows, you would run my_program.exe, and on macOS or Linux, you would run ./my_program.
------------------------------------------------------------------------------------------------------------------------------

* Main Features of C:


- Syntax Simplicity (C is close to natural language)
It refers to the rules and structure governing how code is written and formatted. It determines the correct arrangement of symbols, keywords, and punctuation marks to form valid and working code. 
EX: Code to print Hello Everyone !!! 
  
#include <stdio.h>
int main() {
    printf("Hello Everyone !!!");
    return 0;
}

- Portability
C programs can be easily ported across different platforms with minimal modifications, making it an ideal choice for writing system-level software.

- Efficiency, Modularity, and Extensibility
C offers low-level memory manipulation capabilities, allowing for precise control over system resources and optimal performance. It also supports modular programming through functions and libraries, facilitating code reuse and maintainability.
------------------------------------------------------------------------------------------------------------------------------

* C Language Essentials 1: The Reserved words

C as all the coding language, by opposition to binary (LOL), use keywords to send/receive instructions to the hardware/software. Reserved words are predefined identifiers that have special meanings and are reserved by the language for specific purposes. These words cannot be used as identifiers (such as variable names or function names) by programmers because they are already used by the language itself. 

Here's an example of reserved words in Code to print Hello Everyone: 
1. #include <stdio.h>
2. int main() {
3. printf("Hello Everyone !!!");
4. return 0;
5. }

In the line 1, the keyword is #include. It is  is a pre-processor directive in C that includes the contents of a header file in the program (stdio.h in this case, don't mind this for the moment, it is used to make declarations and definitions available from the standard input/output library).

In the line 2, the keyword is int. This is a keyword in C used to declare integer data types, that is to say variables where we can stock data as a number (for example int a = 5). In this context, it's used to specify the result (return) type of the main function of the program, which is an integer, that is to say a whole number that can be either positive, negative, or zero.

Still in line 2, the keyword is main. This is a special function in C that serves as the entry point of the program, the execution of the program begins from the main function.. It must be defined in every C program, (Some compiler will require int main, others won't, being satisfied by main without int before...).

In the line 3, the keyword is printf: This is a function provided by the standard input/output library in C. It is used to print formatted output to the standard output (usually the console).

In the line 4, the keyword is return: This is a keyword in C used to return a value from a function (also no necessary in some compilers). In the main function, it's used to return an exit status to the operating system, indicating the success or failure of the program execution.
------------------------------------------------------------------------------------------------------------------------------

* C Language Essentials 2: Other Elements of the Syntax 

C have some other elements fundamental for its syntax:

- Case Sensitivity: C is case-sensitive, meaning uppercase and lowercase letters are treated as distinct. For example, Main, main, and MAIN would be interpreted as different identifiers.

- Semicolons: In C, statements are terminated by semicolons (;). Omitting a semicolon at the end of a statement is like a "crime" when coding in C, the code will fail without these fancy semicolons.

- Whitespace: Spaces, tabs, and newlines are collectively known as whitespace and are generally used to improve code readability. In C, whitespace is typically ignored: a + b and a+b are equivalent.

- Comments: Comments are used to add explanatory notes within the code. In C, comments can be written in two forms:
Single-line comments: Begin with // and extend to the end of the line.
Multi-line comments: Enclosed between /* and */ and can span multiple lines.

EX: Updated Code to print Hello Everyone !!! 
1. // This is a single line comment, you cant use the line 2 to pursue your explanatory notes
2. #include <stdio.h>
3. int main() {
4. /* This is a multi line comment. Please use as many explanatory notes as you can, and organise them well 
5. Otherwise, guys who'll read your code will be sad, and angry. */ 
6. printf("Hello Everyone !!!");
7. return 0;
8.}

NB: Code will be presented in this fashion all the way through, trying to prevent copy-paste: please type by yourself, OCR and AI abuse will make you lazy. :)

- Identifiers: They are user-defined names used to represent variables, functions, and other entities in the program. Identifiers must follow specific rules:
A. Must begin with a letter (either uppercase or lowercase) or an underscore (_).
B. Subsequent characters can be letters, digits, or underscores.
C. Cannot be a keyword or contain spaces or special characters.

- Operators: Operators are symbols used to perform operations on operands. C supports various types of operators, including arithmetic, relational, logical, assignment, etc. For example, +, -, *, / are arithmetic operators.
	Don't mind this: Just for good measure, there are also six operators for bit manipulation ( for char, short, int, and long, whether signed or unsigned). They are: & (bitwise AND), | (bitwise inclusive OR), ^ (bitwise exclusive OR), << (left shift), >> (right shift), ~ (one's complement said unary).

- Control Structures: Control structures dictate the flow of execution in a program. Common control structures in C include if-else, switch, for, while, and do-while statements.

- Function Declarations: They are blocks of code that perform a specific task. Function declarations specify the function's return type, name, and possible parameters. The syntax for function declaration is return_type function_name(parameters);.

- Arrays: They are used to store multiple values of the same data type in contiguous memory locations. The syntax for array declaration is datatype array_name[size];.

- Escape Sequences: They are used to represent special characters within strings: \a for the alert (bell) character, \\ for the backslash, \b for backspace, \? for the question mark, \f for form feed, \' for single quote, \n for newline, \" for double quote, \r for carriage return, \ooo for an octal number where ooo represents octal digits, \t for horizontal tab, \xhh for a hexadecimal number where hh represents hexadecimal digits, and \v for vertical tab. 

##############################################################################################################################

* Variables and Arithmetic Expressions

Variables are used to store and manipulate data, there are specific data types. They are named memory locations that can store data., and must be declared with a specific data type before they can be used. There are integers, floating-point numbers, characters, and other variable types.
EX:

int a;            // Integer variable 
float b;          // Floating-point variable 
char c;           // Character variable 

Arithmetic expressions are operands and operators that perform arithmetic calculations. Operands are variables, constants, or values used to do arithmetic operations. Operators are symbols that specify the operation to be performed, + (for addition), - (for subtraction), * (for multiplication), / (for division), and % (for modulus).
EX:

int a = 10, b = 5;
int sum = a + b;        // Addition
int difference = a - b; // Subtraction
int product = a * b;    // Multiplication
int quotient = a / b;   // Division
int remainder = a % b;  // Modulus
int result = (a + b) * (a - b);  // Arithmetic expressions can also include parentheses like in maths

* Variable Type Conversion:

EX:

Implicit Type Conversion:
int a = 5;
float b = 2.5;
float result = a + b; 
In this example, the integer variable a is implicitly converted to a float when it is added to the float variable b.

Explicit Type Conversion (Casting):
int x = 10;
int y = 3;
float division_result = (float)x / y; 

N.B.:
During type Conversion, there may be a loss of precision or unexpected behavior.

------------------------------------------------------------------------------------------------------------------------------
* The For and While statements:

Both for and while statements are control structures of loop, they are used to execute a fragment of code in loop until a defined condition is met.
The for statement is usually used when the number of iterations is known in advance or when a specific range is required. Its syntax consists of 3 parts, it is enclosed in { and separated by ; (semicolons). The first part is the initialisation, where the condition is stated. The second one is the increment part, where the condition is checked. As for the last part, the variables change until the condition is met. 
The while statement is more flexible and is used when the number of iterations is not known, or when the control of the loop is more complex. It also have the same parts; to sum up both are used for iterations in the code.

EX: Program that prints Fahrenheit-Celsius table 

1.  #include <stdio.h>
2.  int main() {
3.  float fa, cel; // You can declare several variable at once
4.  float lower, upper; 
5.  lower = 0; // You notice that the variable was declared prior to assigning it a value here
6.  upper = 200;    
7.  #define steps 10; // #define is used to declare constants or macro substitution 
8.  fa = lower;       // Example of macro sub. that replace TIRD(x) by x/3: #define TIRD(x) (x / 3) 
9.  while (fa <= upper) {
10. // Conversion happens here
11. cel = 5.0 * (fa - 32) / 9.0;  
12. printf("%3.0f\t%6.1f\n", fa, cel); 
13. /* %d is a format specifier used to print integers
14. \t is an escape sequence used to insert a tab character in the output.
15. \n is an escape sequence used to insert a new line 
16. So this command indicate to print an integer, insert a tab, print an integer, insert a tab, than jump a line, before specifying 
17. the variables to print */ 
18. fa = fa + steps;
19. }
20. return 0;
11. }

N.B.:
%6d   print as decimal integer, at least 6 characters wide
%f    print as floating point
%6f   print as floating point, at least 6 characters wide
%.2f  print as floating point, 2 characters after decimal point
%6.2f print as floating point, at least 6 wide and 2 after decimal point, so %6.1 with 1 decimal instead of 2
%3.0f print as floating point, at least 3 wide and 0 after decimal point

------------------------------------------------------------------------------------------------------------------------------
* Character Input and Output

The standard library's input and output model is determined: text input or output, regardless of its source or destination, is treated as streams of characters. Each stream represents a sequence of characters divided into lines, where each line consists of zero or more characters followed by a newline character. 
Within the standard library, several functions facilitate reading or writing one character at a time, with getchar and putchar being the simplest. The keyword getchar retrieves the next input character from a text stream each time it's called, while putchar prints a character whenever it's invoked. 

- Character Counting and Copying

With just getchar and putchar, a program can effectively copy its input to output character by character until it encounters an end-of-file indicator. The putchar(c) function is a standard C function that is used to output a single character to the standard output (usually the terminal). The function getchar() is another standard C library function used to read a single character from the standard input (usually the keyboard) and return its ASCII value as an integer. 

Characters are stored internally as bit patterns, with the char type specifically designed for such storage. However, any integer type can serve this purpose, with int often preferred for its ability to hold both characters and the end-of-file indicator, EOF.
A concise approach to file copying can be achieved by embedding the getchar assignment within the condition of a while loop, enabling a streamlined structure for the program. Caution, ( ) are necessary for the syntax: otherwise, the code won't work.

EX: Program that counts characters in input

1.  #include <stdio.h>
2.  int main()
3.  {
4.  long nc;
5.  nc = 0;
6.  while (getchar() != EOF){
7.  ++nc; // use ++ to add 1, and -- to substract 1
8.  printf("%ld\n", nc);
9.  }
10. return 0;
11. }

N.B.:
CTRL+D send "end-of-file" (EOF) signal, you need to use this combination in the terminal after opening the program and entering data for it to run properly, and see the result. This signal, by opposition to CTRL+C that end programs and terminal process, informs instead the shell that user has no more data to input.
Caution, for non-unix that is to say for an OS different from macOS and Linux, such as evil Windows, it's not CTRL+D but CTRL+Z.

EX: Program that counts the number of lines in input

1.  #include <stdio.h>
2.  int main() {
3.  int c;
4.  int line_count = 0; 
5.  while ((c = getchar()) != EOF) {
6.  putchar(c);
7.  if (c == '\n') { // If newline character is encountered
8.  line_count++; // add 1 to  line_count variable
9.  }
10. }
11. }
12. printf("Total number of lines: %d\n", line_count);
13. return 0;           
14. }

N.B.: 
The terminal will echo what u type it's normal, we ll see later how to prevent that from happening

------------------------------------------------------------------------------------------------------------------------------
* Arrays, and Creation of Functions

An array is like one or several cells of an excel sheet, arrays are essential data structures. It allows the storage and management of multiple values of the same type under a single name, allowing efficient data grouping and manipulation.  

- Defining and Initialising Arrays

int numbers[7]; or int numbers[6] = {3, 5, 7, 11, 19, 33}; to declare while initialising, [6] = {1,2}; is possible but other elements will be set to 0. Matrix are possible, with int matrix[4][4];    

EX: Program that counts the number of characters each line and print the longest

1. #include <stdio.h>
2. #define MAXLENGTH 1000
3. int fetch_line(char buffer[], int maxlength);
4. void transfer(char destination[], char source[]);
5. int main() {
6. int length;
7. int maxLength = 0;
8. char buffer[MAXLENGTH];
9. char maxBuffer[MAXLENGTH];
10. while ((length = fetch_line(buffer, MAXLENGTH)) > 0) {
11. if (length > maxLength) {
12. maxLength = length;
13. transfer(maxBuffer, buffer);
14. }
15. }
16. if (maxLength > 0)
17. printf("%s", maxBuffer);
18. return 0;
19. }
20. int fetch_line(char str[], int limit) {
21. int character, index;
22. for (index = 0; index < limit - 1 && (character = getchar()) != EOF && character != '\n'; ++index)
23. str[index] = character;
24. if (character == '\n') {
25. str[index] = character;
26. ++index;
27. }
28. str[index] = '\0';
29. return index;
30. }
31. void transfer(char destination[], char source[]) {
32. int idx = 0;
33. while ((destination[idx] = source[idx]) != '\0')
34. ++idx;
35. }

- What is a Function

It's a building block, encapsulating specific tasks to enhance code modularity and readability. 
Again, fetch_line is the function that retrieve input characters until it encounters an end-of-file (EOF) or a newline character ('\n'). Functions have parameters, fetch_line has a buffer[] (an array to store the input characters) and a limit (the maximum number of characters to read).

- Creating a Function

It is done in 5 steps: 
A- Declaration (Prototype), where is the function's name, return type, and possible parameters
B- Definition, where are the function's return type name, possible parameters, and the body of the function enclosed in {}
C- Function Body
D- Possible Return Statement (if applicable), where the value to be returned is set
E- Function Call, to use the function (not necessarily right after the previous step, but when the function is needed)

EX: Dumb Function Code that add two numbers (no need for CTR+D here)

1.  #include <stdio.h>
2.  int dumb_function(int essence1, int essence2);
3.  int main() {
4.  int essence1, essence2, outcome;
5.  scanf("%d", &essence1);
6.  scanf("%d", &essence2);
7.  outcome = dumb_function(essence1, essence2); 
8.  printf("The dumb function reveals: %d\n", outcome); 
9.  return 0;
10. }
11. int dumb_function(int essence1, int essence2) {
12. int convergence = essence1 + essence2; 
13. return convergence;
14. }

------------------------------------------------------------------------------------------------------------------------------
* External Variables:

- What are they?

Variables within functions are like temporary entities, because they are lost outside of their function. However, there's an alternative: external variables, defined outside any function and declared in each function that uses them. 
The process involves declaring the variables as "extern" within functions to access them. 
N.B.: You can avoid using extern, but keep in mind it needs to be done before its use, and that a well-coded program should be memory-efficient.

- How to use them?

You can use them in 3 steps: 

A- Declaration (may be in a header file, for long code, like dumb_header.h)
extern int globalVariable; 
B- Definition
int globalVariable = 10;
C- Access
void someFunction() {
printf("The value of globalVariable is: %d\n", globalVariable);
}
N.B.: When compiling your program and using a header, make sure to include it in the code, and when having multiple c files to compile all source files together (gcc -o program random_dumb_code_1.c random_dumb_code_2.c).

EX: A program with 1 c file and 1 header (to compile it, only run: gcc -o program random_dumb_code.c) 

EX_part_1: dumb_header.h
1. extern int globalVariable;

EX_part_2: random_dumb_code.c
1. #include "dumb_header.h"
2. blablabla...

EX: Program that print the longest line with an external variable, but without a header file 

1.  #include <stdio.h>
2.  #define MAXLINE 3000
3.  int maximum;
4.  char input[MAXLINE];
5.  char longest_line[MAXLINE];
6.  int read_line(void);
7.  void duplicate(void);
8.  int main() {
9.  int length;
10. maximum = 0;
11. while ((length = read_line()) > 0) {
12. if (length > maximum) {    
13. maximum = length;    
14. duplicate();    
15. }       
16. }            
17. if (maximum > 0) {            
18. printf("%s", longest_line);        
19. }    
20. return 0;    
21. }        
22. int read_line(void) {    
23. int character, index;    
24. for (index = 0; index < MAXLINE - 1 && (character = getchar()) != EOF && character != '\n'; ++index) {
25. input[index] = character;
26. }
27. if (character == '\n') {    
28. input[index] = character;    
29. ++index;        
30. }    
31. input[index] = '\0';   
32. return index;        
33. }        
34. void duplicate(void) {    
35. int index;    
36. for (index = 0; (longest_line[index] = input[index]) != '\0'; ++index) {    

##############################################################################################################################

* Conditional Expressions

A conditional expression (ternary operator) is a way to return one of 2 values depending on whether a condition is met, with a simple syntax (the_condition ? expression_1 : expression_2;). There are 2 main types of conditional expression, if-else and else-if.

- If-else

The if-else statement is an expression that determines whether a condition holds true or false, it has two blocks. If the condition is true, the code block inside the if statement is executed. Otherwise, the code block inside the else statement is executed. Its syntax is:
if (condition) {
    // Block to be executed if the condition is true
} else {
    // Block to be executed if the condition is false
}

- Else-if

Else-if ladder allows for multiple conditions to be checked in sequence, with the following syntax:
if (condition1) {
    // Block of code to be executed if condition1 is true
} else if (condition2) {
    // Block of code to be executed if condition2 is true
} else if (condition3) {
    // Block of code to be executed if condition3 is true
}
// Optionally, an else block can be added at the end to handle the case where none of the conditions are true.
else {
    // Block of code to be executed if none of the conditions are true
}

EX: Dumb code showing how if, else, and else if work

1.  #include <stdio.h>
2.  int main() {
3.  int num;
4.  printf("Enter an integer: ");
5.  scanf("%d", &num);
6.  if (num % 2 == 0) {
7.  printf("The number is even (using only if).\n");
8.  } else {
9.  printf("The number is odd (using only if).\n");
10. }
11. if (num % 2 == 0) {
12. printf("The number is divisible by 2 (using else-if).\n");
13. } else if (num % 5 == 0) {
14. printf("The number is divisible by 5 (using else-if).\n");
15. } else {
16. printf("The number is not divisible by 2 or 5 (using else-if).\n");
17. }
18. return 0;
19. }

------------------------------------------------------------------------------------------------------------------------------
* Operator Associativity

It determines the order in which operators of the same precedence level are evaluated, 5 + 6 - 2; means (5 + 6) - 2 while 5 + 6 * 2 means 5 + (6 * 2). Best Practices, Google-like coding requirements, are not presumptuous rules. The goal is not to be fancy, but to write good code. 
So, avoid Undefined Behavior by not changing the same variable multiple times within a single expression without a sequence point, like (,) or (;) or (&&).
And use parentheses to explicitly specify the order of evaluation when the expression might be ambiguous, better be late than sorry with thousands of lines to check. Here are some hypothetical mistakes:

- Function Calls: The compiler can choose to evaluate either foo() or bar() first, and mess with the result

int foo() {
    printf("Inside foo()\n");
    return 5;
}
int bar() {
    printf("Inside bar()\n");
    return 10;
}
int main() {
    int result = foo() + bar();
    return 0;
}
In this example, the order of evaluation of foo() and bar() is not specified.  Therefore, the output could be "Inside foo()\nInside bar()\n" or "Inside bar()\nInside foo()\n", depending on the compiler's choice.

- Logical Operators: The (&&) operator has short-circuit behavior, if (a > b) is false than (b > c) is not even tested

int a = 5, b = 10, c = 15;
int result = (a > b) && (b > c);

- Undefined Behavior: No sequence points will lead to unpredictable behavior
int x = 5;
int y = x++ * ++x;

------------------------------------------------------------------------------------------------------------------------------
* The Switch Statement, Break, and Continue 

- It's a testing keyword for making multi-way decisions, it does so by comparing an expression to a set of constant integer values and branching accordingly. 
When the expression matches one of these cases, the program execution starts from that point. It's important to note that all case expressions must be distinct. As for the optional default case, it's for when no other cases match the expression value. 

- The break statement is a control flow statement used to exit immediately from loops and switch statements. It is primarily used to terminate the current iteration of a loop or to exit a switch statement after a particular case has been executed.
NB: It's advisable to include a break statement after the last case, for defense.

- In a switch statement, the break statement is used to exit immediately from the switch block. This prevents the execution from falling through to the next case. If no break statement is encountered, the program will continue executing the code in the subsequent cases, leading to fall-through behavior.

- The continue statement is used inside loops to immediately jump to the next iteration of the loop without executing the remaining code in the loop's body. 
When encountered, continue causes the program execution to jump directly to the loop's condition check or increment/decrement statement (depending on the loop type), bypassing any remaining statements in the loop's body.
In a loop, continue is typically used within if statements to control the flow of execution inside the loop based on certain conditions. When a continue statement is encountered, the loop immediately proceeds to the next iteration.

EX: Dumb code to tell the name of the week day, with Monday as the first one 

1.  #include <stdio.h>
2.  int main() {
3.  int day;
4.  printf("Enter a number (1-7): ");
5.  scanf("%d", &day);
6.  switch (day) {
7.  case 1: printf("Monday\n"); break; // Here is a compact way to code putting several instruction line in one with (;)
8.  case 2: printf("Tuesday\n"); break;
9.  case 3: printf("Wednesday\n"); break;
10. case 4: printf("Thursday\n"); break;
11. case 5: printf("Friday\n"); break;
12. case 6: printf("Saturday\n"); break;w 
13. case 7: // Here is the regular way to write it
14. printf("Sunday\n"); 
15. break;
16. default: printf("Invalid input\n"); break;
17. }
18. return 0;
19. }

------------------------------------------------------------------------------------------------------------------------------
* The Do-While, Goto, and Labels

- Do-While is a loop that execute a block of code repeatedly, until a specified condition becomes false. It tests the condition after the loop body executes, which ensure that the loop body run at least once. Its syntax is: 
do {
    // Code block to be executed
} while (condition);

EX: Print the number i, equal to 1 at first, and adding to it 1 each time using a do-while loop until i < or = to 5

1. #include <stdio.h>
2. int main() {
3. int i = 1;
4. do {
5. printf("%d ", i);
6. i++;
7. } while (i <= 5);
8. return 0;
9. }

- Goto dates back to the old times, (when Boomers were playing in easy mode, and "nerds" coding in BASIC language). It allows to jump to a desired section of the code, without executing any previous instructions to the said desired section. It relies on labels. They are a way to name code sections easily, just by typing for instance: (dumb_section:).

EX: Same code, but jumping directly to a low-key insult (written for dramatic purposes, not directed to anyone, not even my ex)
1.  #include <stdio.h>
2.  int main() {
3.  int i = 1;
4.  goto not_today // nothing between here 
5.  do {
6.  printf("%d ", i);
7.  i++;
8.  } while (i <= 5); // and here will be ran
9.  not_today:
10. printf("Not today, punk"); 
8.  return 0;
9.  }

------------------------------------------------------------------------------------------------------------------------------
* Blocks, Initialisation, Recursion

- In C, you cannot nest function within other functions like in python. Yet, block-level variable scoping allow variables to be defined within blocks that is to say code enclosed within curly braces within a function. 
Variables declared within a block hide identically named variables in outer blocks, they do so by remaining in existence until the block they're defined in ends.
Good practice recommended to avoid variable names that conceal names in an outer scope, in order to prevent confusion and errors.

EX: the use of x variables in this code is just ugly
#include <stdio.h>
int x = 10; // Global variable
int main() {
    int x = 20; // Local variable, hiding the global variable 'x'
    printf("Local x: %d\n", x); // Prints the value of local 'x'
    printf("Global x: %d\n", ::x); // Prints the value of global 'x'
    return 0;
}

- In Explicit Initialisation, Variables can be initialised when they're defined by following the name with an equals sign and an expression. As for the External and static variables, they are guaranteed to be initialised to zero in the absence of explicit initialisation. Arrays and character arrays have specific initialisation rules, as seen earlier.

- Recursion is supported in C, allowing functions to call themselves either directly or indirectly. Each invocation of a recursively called function gets its own set of automatic variables. 
Recursion can provide a more compact and often easier-to-understand solution compared to non-recursive alternatives, like old-fashioned trees (or my first codes (╥﹏╥), now buried with IT game cartridges, RIP Atari).

##############################################################################################################################

* Pointers and Addresses

- Pointers direct towards the exact locations of data, allowing a better memory management. Memory is like a vast array of cells, each with its unique address. These cells can be arranged in various configurations, from individual bytes to groups forming integers or longer entities.

- A pointer is like a GPS coordinate, holding the precise location of a variable. For instance, if (a) is a character and (p) is its  pointer, we visualise it like this with (&) and (*) operators:

char a;
char *p = &a; // The & operator fetches the address of a, assigning it to the pointer p (*p). 
int x = 42;
int *ptr = &x;
int value = *ptr; // Value is now 42, retrieved from the treasure chest pointed to by ptr.

N.B.: & can only fetch addresses of tangible objects in memory, not abstract entities or fleeting expressions.

------------------------------------------------------------------------------------------------------------------------------
* Pointers and Function Arguments

C doesn't allow a called function to change a variable while in the calling function, making the following code illegal and non-functional:

1.  #include <stdio.h>
2.  void increment(int x, int amount) {
3.  x += amount;
4.  }
5.  int main() {
6.  int a = 5;
7.  increment(a, 3);
8.  printf("a = %d\n", a);  // The output will be a = 5 :/
9.  return 0;
10. }

- The increment function attempts to add amount to x. However, since x is a copy of the variable passed from the calling function, the original variable is not modified. To solve this problem, we can use macro-substitution with #define: so that the INCREMENT macro directly manipulates the original variable, effectively incrementing its value.

EX: Fixed code with macro-substitution 

1.  #include <stdio.h>
2.  #define INCREMENT(x, amount) \
3.  do { \
4.  (x) += (amount); \
5.  } while (0)
6.  int main() {
7.  int a = 5;
8.  INCREMENT(a, 3);
9.  printf("a = %d\n", a);  // Here the output will be a = 8 :)
10. return 0;
11. }

- The other way to fix is more elegant, it requires pointers. By passing a pointer to the variable, the function can modify the original variable in the calling function. Inside the function, the pointer is dereferenced (*x) to access and modify the value it points to: 

1.  #include <stdio.h>
2.  void increment(int *x, int amount) {
3.  *x += amount;
4.  }
5.  int main() {
6.  int a = 5;
7.  increment(&a, 3);
8.  printf("a = %d\n", a);  // // Here the output will also be a = 8 :)
9.  return 0;
10. }

------------------------------------------------------------------------------------------------------------------------------
* Pointers and Arrays

Pointers allow efficient traversal of an array. Instead of using array indexing, you can increment a pointer to move to the next element in the array. The following example demonstrates array manipulation and function parameter passing, with: 

The array int b[10] is declared, and the pointer int *pb is initialised, and pb = b sets pb to the address of the first element. 
The array is initialised using pointer arithmetic: pb[i] = i * 2; is equivalent to b[i] = i * 2;. 
The array elements are printed using both array indexing (b[i]) and pointer arithmetic (*(pb + i)).

The function displayArray prints the elements of the array using pointer arithmetic. 
The function stringLength calculates the length of a string using pointer incrementing (str++).

1.  #include <stdio.h>
2.  void displayArray(int *arr, int size) {
3.  for (int *ptr = arr; ptr < arr + size; ptr++) {
4.  printf("%d ", *ptr);
5.  }
6.  printf("\n");
7.  }
8.  int stringLength(const char *str) {
9.  const char *start = str;
10. while (*str) str++;
11. return str - start;
12. }
13. int main() {
14. int b[10], *pb = b;
15. for (int i = 0; i < 10; i++) {
16. pb[i] = i * 2;
17. }
18. printf("Using array indexing:\n");
19. for (int i = 0; i < 10; i++) {
20. printf("%d ", b[i]);
21. }
22. printf("\n");
23. printf("Using pointer arithmetic:\n");
24. for (int i = 0; i < 10; i++) {
25. printf("%d ", *(pb + i));
26. }
27. printf("\n");
28. for (int i = 2; i < 7; i++) {
29. pb[i] += 10;
30. }
31. displayArray(b, 10);
32. const char *text = "Hello, world!";
33. printf("Length of the string \"%s\": %d\n", text, stringLength(text));
34. return 0;
35. }

------------------------------------------------------------------------------------------------------------------------------
* Address Arithmetic 

- If p is a pointer to an element in an array, then p++ increments p to point to the next element, and p+=i increments it to point i elements beyond its current position. Storage allocator requires routines: alloc(n) returns a pointer to n consecutive characters, and afree(p) releases the storage so it can be reused. These routines operate as a stack (last-in, first-out).

- The standard library functions malloc and free perform similar tasks without such restrictions. A pointer can be initialised just like any other variable. For instance, static char *allocp = allocbuf; defines allocp as a character pointer and initializes it to point to the beginning of allocbuf.

- Pointer arithmetic includes adding or subtracting integers to/from pointers, comparing pointers, and pointer subtraction to find the number of elements between two pointers. 

EX: Dumb code illustrating routines by printing the length of a string

#include <stdio.h>

#define ALLOCSIZE 10000 // This number of bytes is symbolic, and define memory allocation 
static char allocbuf[ALLOCSIZE]; // A much lower value would severely limit the amount of memory and could lead to issues
static char *allocp = allocbuf;

char *alloc(int n) { if (allocbuf + ALLOCSIZE - allocp >= n) { allocp += n; return allocp - n; } else { return 0; } }
void afree(char *p) { if (p >= allocbuf && p < allocbuf + ALLOCSIZE) { allocp = p; } }
int strLength(const char *s) { const char *p = s; while (*p != '\0') p++; return p - s; }

void exampleArrayPointer() { int a[10], *pa = a; for (int i = 0; i < 10; i++) { pa[i] = i * 2; } for (int i = 0; i < 10; i++) { printf("%d ", a[i]); } printf("\n"); for (int i = 0; i < 10; i++) { printf("%d ", *(pa + i)); } printf("\n"); }

int main() { exampleArrayPointer(); char *p1 = alloc(50); char *p2 = alloc(100); afree(p2); char *p3 = alloc(30); const char *str = "Hello, world!"; printf("Length of \"%s\": %d\n", str, strLength(str)); return 0; }

------------------------------------------------------------------------------------------------------------------------------
* Character Pointers and Functions 

- Strings are typically represented as arrays of characters terminated by a null character '\0'. When using string constants in a program, they are accessed through a character pointer. For example, printf("hello, world\n"); receives a pointer to the beginning of the character array "hello, world\n".

- String constants can also be explicitly assigned to character pointers. For instance, char *pmessage = "now is the time"; assigns pmessage to point to the character array "now is the time". It's important to note that this assignment only sets the pointer to the (read only) memory location of the string constant, not the string itself.

- There's a significant distinction between declaring a character array and a character pointer for strings. An array declaration like char amessage[] = "now is the time"; creates a mutable array that holds the string's contents. On the other hand, char *pmessage = "now is the time"; initialises pmessage as a pointer to the read-only string constant.

EX: Dumb code demonstrating how pointer arithmetic can efficiently access and modify string data

/* strcpy: copy string t to s using pointer notation */
void strcpy(char *s, char *t) {
while ((*s++ = *t++) != '\0')
;
}
/* strcmp: compare strings s and t using pointer notation */
int strcmp(char *s, char *t) {
for ( ; *s == *t; s++, t++)
if (*s == '\0')
return 0;
return *s - *t;
}
int main() {
char dest[20]; // Destination array for strcpy
char *str1 = "Hello"; char *str2 = "World";
strcpy(dest, str1); printf("Copied string: %s\n", dest); // Copy str1 to dest and print it
int cmp_result = strcmp(str1, str2); printf("Comparison result: %d\n", cmp_result); // Compare str1 and str2 and print it 
return 0;
}

##############################################################################################################################

* Pointers to Pointers

- Pointers can be stored in arrays, enabling powerful and flexible data structures. To sort lines of text by alphabetic order, an array of pointers to strings can be used. This approach efficiently handles variable-length text lines, as each line can be accessed via a pointer to its first character, with only pointers swapped instead of the actual text lines.

- The sorting process involves three steps: reading input lines, sorting them, and printing them in order. The input routine collects and saves each line's characters, building an array of pointers to these lines. 

- The core of this approach is the array of pointers. The input lines are stored end-to-end in a single character array, with each line accessible via a pointer. Sorting algorithms like quicksort can be adapted to work with these pointers, using functions like strcmp for comparisons and swapping pointers instead of text lines to minimise overhead.

Ex: Quicksort code sorting inputed lines alphabetically from z to a

1.  #include <stdio.h>  // Standard I/O functions
2.  #include <stdlib.h>  // Standard library functions
3.  #include <string.h>  // String handling functions

4.  #define MAXITEMS 5000  // Maximum number of items
5.  char *items[MAXITEMS];  // Array to store item pointers

6.  int readitems(char *items[], int maxitems);  // Function to read items
7.  void writeitems(char *items[], int nitems);  // Function to write items
8.  void sort(char *items[], int left, int right);  // Function to sort items

9.  int main() {
10. int nitems;
11. if ((nitems = readitems(items, MAXITEMS)) >= 0) {  // Read items
12. sort(items, 0, nitems-1); writeitems(items, nitems); return 0;  
13. } else {
14. printf("error: input too big to sort\n"); return 1;  
15. }
16. }

17: #define MAXLEN 1000  // Maximum length of input line
18: int getinput(char *, int);  
19: char *allocate(int);  // Function to allocate memory

20: int readitems(char *items[], int maxitems) {
21: int len, nitems;
22: char *p, line[MAXLEN];
23: nitems = 0;
24: while ((len = getinput(line, MAXLEN)) > 0) {  // Get input line
25: if (nitems >= maxitems || (p = allocate(len)) == NULL)  // Check limits
26: return -1; // we will see error handling later
27: else {
28: line[len-1] = '\0';  // Remove newline
29: strcpy(p, line);  // Copy line to allocated memory
30: items[nitems++] = p;  // Store pointer
31: }
32: }
33: return nitems;  // Return number of items read
34: }

35: void writeitems(char *items[], int nitems) {
36: while (nitems-- > 0) printf("%s\n", *items++);  // Print each item
37: }

38: void sort(char *v[], int left, int right) {
39: int i, last;
40: void exchange(char *v[], int i, int j);  // Function to exchange elements
41: if (left >= right) return;  // Base case
42: exchange(v, left, (left + right)/2);  // Move pivot element
43: last = left;
44: for (i = left+1; i <= right; i++)  // Partition
45: if (strcmp(v[i], v[left]) > 0) exchange(v, ++last, i);  // Exchange
46: exchange(v, left, last);  // Restore pivot
47: sort(v, left, last-1);  // Sort left part
48: sort(v, last+1, right);  // Sort right part
49: }

50: void exchange(char *v[], int i, int j) {
51: char *temp = v[i]; v[i] = v[j]; v[j] = temp;  // Swap elements
52: }

53: int getinput(char *s, int lim) {
54: int c, i;
55: for (i = 0; i < lim-1 && (c = getchar()) != EOF && c != '\n'; i++) s[i] = c;  // Read line
56: if (c == '\n') { s[i] = c; i++; }  // Append newline
57: s[i] = '\0';  // Null terminate
58: return i;  // Return length
59: }

60: #define ALLOCSIZE 10000  // Size of allocation buffer
61: static char allocbuf[ALLOCSIZE];  // Buffer for allocations
62: static char *allocp = allocbuf;  // Next free position

63: char *allocate(int n) {
64: if (allocbuf + ALLOCSIZE - allocp >= n) {  // Check space
65: allocp += n;  // Move pointer
66: return allocp - n;  // Return start of allocated memory
67: } else
68: return 0;  // No space left
69: }

------------------------------------------------------------------------------------------------------------------------------
* Multi-dimensional Arrays

- They are often implemented using arrays of arrays rather than as rectangular multi-dimensional arrays. This approach is demonstrated in functions like student_average and highest_grade, which manage student grades across subjects. These functions utilise a two-dimensional array grades to store grades for each student and each subject, enabling efficient data manipulation.

- The Data is represented as follow: the grades array is defined as int grades[NUM_STUDENTS][NUM_SUBJECTS], where rows represent students and columns represent subjects. The Functions to define for this example could be compute_average** that computes the average grade for a specified student index, and find_highest_grade that identifies the highest grade in a subject index. 

- The grades array allows direct access to student grades, optimising operations like average computation and finding maximum values. The array notation (grades[i][j]) allow access to the elements efficiently, by student and by subject indices. When passing grades to functions, its declaration specifies both dimensions (int grades[NUM_STUDENTS][NUM_SUBJECTS]). 

- Parameter Passing is possible: Function declarations for grades include options like f(int grades[NUM_STUDENTS][NUM_SUBJECTS]), f(int grades[][NUM_SUBJECTS]), or f(int (*grades)[NUM_SUBJECTS]), indicating the structure of the array being passed.

EX: Code that compute student grade averages and find highest subject grades 

 1. #include <stdio.h>
 2. #define NUM_STUDENTS 5
 3. #define NUM_SUBJECTS 3
 4. double compute_average(int grades[NUM_STUDENTS][NUM_SUBJECTS], int student_index);
 5. int find_highest_grade(int grades[NUM_STUDENTS][NUM_SUBJECTS], int subject_index);
 6. int main() {
 7. int grades[NUM_STUDENTS][NUM_SUBJECTS] = {{85, 90, 88}, {70, 65, 75}, {95, 92, 88}, {60, 55, 70}, {80, 85, 82}};
 8. int student_index = 2;
 9. double average_grade = compute_average(grades, student_index);
10. printf("Average grade for student %d: %.2f\n", student_index + 1, average_grade);
11. int subject_index = 1;
12. int highest_grade = find_highest_grade(grades, subject_index);
13. printf("Highest grade in subject %d: %d\n", subject_index + 1, highest_grade);
14. return 0;
15. }
16. double compute_average(int grades[NUM_STUDENTS][NUM_SUBJECTS], int student_index) {
17. double sum = 0.0;
18. for (int j = 0; j < NUM_SUBJECTS; j++) {
19. sum += grades[student_index][j];
20. }
21. return sum / NUM_SUBJECTS;
22. }
23. int find_highest_grade(int grades[NUM_STUDENTS][NUM_SUBJECTS], int subject_index) {
24. int max_grade = grades[0][subject_index];
25. for (int i = 1; i < NUM_STUDENTS; i++) {
26. if (grades[i][subject_index] > max_grade) {
27. max_grade = grades[i][subject_index];
28. }
29. }
30. return max_grade;
31. }

Keep in mind that, by opposition to arrays, accessing a pointer element requires two steps: first accessing an array of pointers, then accessing a specific element within the pointed array.

------------------------------------------------------------------------------------------------------------------------------
* Command-line Arguments

- In C language, you can give command-line arguments to a program when it starts. The main function receives two parameters: argc (argument count) that is the number of command-line arguments, and argv (argument vector) which is an array of character strings representing the arguments.

- The argument argc is at least 1 because argv[0] is the program name, and argv[1] to argv[argc-1] are the additional arguments. As for argv[argc], it is always a NULL pointer. You can manipulate argv directly, ++argv shifts the pointer to the next argument. Options like -x that exclude matching lines and -n that Print line numbers are supported, as well as combining options like -nx.

- Getline Function can read a line from the standard input and returns its length. If fgets returns NULL, it means the end of input has been reached, and the function returns 0. For instance, find pattern prints lines that contain pattern, find -x pattern prints lines that do not contain pattern, find -n pattern prints lines that contain pattern, preceded by their line numbers.

EX: Code with command line Optional Arguments Changes 

1.  #include <stdio.h>
2.  #include <string.h>
3.  #define MAXLINE 1000
4.  int get_line(char *line, int max);
5.  int main(int argc, char *argv[]) {
6.  char line[MAXLINE];
7.  long lineno = 0;
8.  int c, except = 0, number = 0, found = 0;
9.  argv[0] = "new_program_name";
10. while (--argc > 0 && (*++argv)[0] == '-') {
11. while ((c = *++argv[0])) {
12. switch (c) {
13. case 'x': except = 1; break;
14. case 'n': number = 1; break;
15. default:
16. printf("find: illegal option %c\n", c);
17. argc = 0;
18. found = -1;
19. break;
20. }
21. }
22. }
23. if (argc != 1) {
24. printf("Usage: find -x -n pattern\n");
25. } else {
26. printf("Enter lines (press Enter to exit):\n");
27. while (get_line(line, MAXLINE) > 0) {
28. lineno++;
29. if ((strstr(line, *argv) != NULL) != except) {
30. if (number) {
31. printf("%ld:", lineno);
32. }
33. printf("%s", line);
34. found++;
35. }
36. }
37. }
38. printf("Press Enter to exit...");
39. while (getchar() != '\n') {
40. }
41. return found;
42. }
43. int get_line(char *line, int max) {
44. if (fgets(line, max, stdin) == NULL) {
45. return 0;
46. } else {
47. return strlen(line);
48. }
49. }

Note that changing the program's name on system monitor or htop (top if ur insane) requires system-specific calls, :/ that are not mentioned in this textbook.  

------------------------------------------------------------------------------------------------------------------------------
*Pointers to Functions 

Here are the 3 tools to define pointers to functions: qsort is a standard library function in C used for sorting arrays, strcmp compares two null-terminated strings, and numcmp is a custom comparison function for sorting numeric strings.

QSORT: void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
base = Pointer to the first element of the array to be sorted.
nmemb = Number of elements in the array.
size = Size of each element in the array (in bytes).
compar = Pointer to a comparison function that determines the order of elements.

STRCMP: int strcmp(const char *str1, const char *str2);
It returns an integer less than, equal to, or greater than zero if str1 is found, respectively, to be less than, to match, or be greater than str2.

NUMCMP: Converts string representations of numbers (s1 and s2) to double, then compares them numerically.

EX: Sorting Strings Lexicographically and Numerically using qsort 
In Lexicography, h (104) is less than n (110) in terms of ASCII values, thus "hello" is less than "no" lexicographically.

1.  #include <stdio.h>
2.  #include <stdlib.h>
3.  #include <string.h>
4.  #define MAX_STRINGS 5
5.  int compare_lexicographic(const void *a, const void *b) {
6.  const char *str1 = *(const char **)a;
7.  const char *str2 = *(const char **)b;
8.  return strcmp(str1, str2);
9.  }
10. int numcmp(const char *s1, const char *s2) {
11. double v1 = atof(s1);
12. double v2 = atof(s2);
13. if (v1 < v2) return -1;
14. else if (v1 > v2) return 1;
15. else return 0;
16. }
17. int compare_numeric(const void *a, const void *b) {
18. const char *str1 = *(const char **)a;
19. const char *str2 = *(const char **)b;
20. return numcmp(str1, str2);
21. }
22. int main() {
23. char *strings[MAX_STRINGS] = {"42", "3.14", "99", "100", "25"};
24. qsort(strings, MAX_STRINGS, sizeof(char *), compare_lexicographic);
25. printf("Sorted lexicographically:\n");
26. for (int i = 0; i < MAX_STRINGS; i++) {
27. printf("%d. %s\n", i + 1, strings[i]);
28. }
29. qsort(strings, MAX_STRINGS, sizeof(char *), compare_numeric);
30. printf("\nSorted numerically:\n");
31. for (int i = 0; i < MAX_STRINGS; i++) {
32. printf("%d. %s\n", i + 1, strings[i]);
33. }
34. return 0;
35. }

------------------------------------------------------------------------------------------------------------------------------
* Complicated Declarations

- The C language declaration syntax aims to ensure consistency between declaration and usage, it can be difficult to read and understand for more complex cases. This complexity arises due to the precedence rules of operators like * and (), which require careful use of parentheses to maintain correct association.

- To illustrate the parsing of C declarations, let's create a code that contains various complex declarations and uses of function pointers and arrays of function pointers. It includes a simple function, `simpleFunction`, which takes an integer and returns twice its value. The program declares a function pointer `funcPtr`, an array of five function pointers `arrayOfFuncPtrs`.

- It also contains a pointer to an array of five function pointers `ptrToArrayOfFuncPtrs`, and a function `functionReturningFuncPtr` that returns a function pointer. Additionally, it declares a multidimensional array `arrayOfArraysOfFuncPtrs` consisting of five arrays, each containing ten function pointers. 

EX: Complex C Declarations Involving Pointers to Functions and Arrays of Function Pointers

1. #include <stdio.h>
2. int simpleFunction(int a) {
3. return a * 2;
4. }
5. int (*funcPtr)(int);
6. int (*arrayOfFuncPtrs[5])(int);
7. int (*(*ptrToArrayOfFuncPtrs)[5])(int);
8. int (*functionReturningFuncPtr(int a))(int) {
9. return simpleFunction;
10. }
11. int (*arrayOfArraysOfFuncPtrs[5][10])(int);
12. int main() {
13. funcPtr = simpleFunction;
14. printf("Result from funcPtr: %d\n", funcPtr(2));
15. for (int i = 0; i < 5; i++) {
16. arrayOfFuncPtrs[i] = simpleFunction;
17. }
18. printf("Result from arrayOfFuncPtrs[2]: %d\n", arrayOfFuncPtrs[2](3));
19. ptrToArrayOfFuncPtrs = &arrayOfFuncPtrs;
20. printf("Result from ptrToArrayOfFuncPtrs[0][3]: %d\n", (*ptrToArrayOfFuncPtrs)[3](4));
21. int (*returnedFuncPtr)(int) = functionReturningFuncPtr(5);
22. printf("Result from returnedFuncPtr: %d\n", returnedFuncPtr(6));
23. for (int i = 0; i < 5; i++) {
24. for (int j = 0; j < 10; j++) {
25. arrayOfArraysOfFuncPtrs[i][j] = simpleFunction;
26. }
27. }
28. printf("Result from arrayOfArraysOfFuncPtrs[3][4]: %d\n", arrayOfArraysOfFuncPtrs[3][4](7));
29. return 0;
30. }

- Let's highlight as an example a potential area where complexity might have compromised the code: (*funcPtr) declares funcPtr as a pointer to a function that takes an int and returns an int. If not properly parenthesised, it could be misunderstood as a function returning a pointer.

##############################################################################################################################

* Structure and Functions

- Structures, also known as records, are a way to group variables of different types under a single name. They are particularly useful in organising complex data within large programs by treating related variables as a cohesive unit rather than individual entities. For instance, a point in a 4 dimension space:

struct point {
    float x;
    float y;
    float z;
    int t;
};

- Structures can also be nested, such as in the case of defining a rectangle using two points:

struct cube {
    struct point vertices[8];
};

- Here, struct point defines a type consisting of three floats x, y, and z which represent coordinates and one integer which represent time. Structures can be initialised and accessed using the . operator, like that: 

myCube.vertices[0] = (struct point) {0.0, 0.0, 0.0, 0};

- Operations on structures include copying, assigning, passing to functions, and returning from functions as a unit. Pointers to structures use the -> notation for member access, like follow:

int main() {
    // Define a pointer to a struct point
    struct point *pp;
    // Allocate memory for a struct point
    pp = (struct point *)malloc(sizeof(struct point));

    // Initialize the members of the struct point using -> notation
    pp->x = 10.5;
    pp->y = 20.5;
    pp->z = 30.5;
    pp->t = 1;

    // Access and print the members using -> notation
    printf("Coordinates: x = %f, y = %f, z = %f, t = %d\n", pp->x, pp->y, pp->z, pp->t);
    // Free allocated memory
    free(pp);
    return 0;
}

EX: Code that initialise a cube vertices through structures and print it vertex at time 0  

 1. #include <stdio.h>
 2. struct point {
 3. float x;
 4. float y;
 5. float z;
 6. int t;
 7. };
 8. struct cube {
 9. struct point vertices[8];
10. };
11. int main() {
12. // Define a cube
13. struct cube myCube;
14. // Initialize vertices of the cube
15. myCube.vertices[0] = (struct point) {0.0, 0.0, 0.0, 0};
16. myCube.vertices[1] = (struct point) {1.0, 0.0, 0.0, 0};
17. myCube.vertices[2] = (struct point) {1.0, 1.0, 0.0, 0};
18. myCube.vertices[3] = (struct point) {0.0, 1.0, 0.0, 0};
19. myCube.vertices[4] = (struct point) {0.0, 0.0, 1.0, 0};
20. myCube.vertices[5] = (struct point) {1.0, 0.0, 1.0, 0};
21. myCube.vertices[6] = (struct point) {1.0, 1.0, 1.0, 0};
22. myCube.vertices[7] = (struct point) {0.0, 1.0, 1.0, 0};
23. // Accessing a vertex
24. printf("Vertex 0: (%f, %f, %f, %d)\n", myCube.vertices[0].x, myCube.vertices[0].y, myCube.vertices[0].z, myCube.vertices[0].t);
25. return 0;
26. }

------------------------------------------------------------------------------------------------------------------------------
* Arrays of Structures

- An array of structures in C is a collection where each element is a structure of the same type. This allows you to manage multiple instances of structured data sequentially in memory, in 2 steps: Definition, Initialisation and Access. They are useful when you need to store and manipulate collections of related data items, like records in a database.

1. Definition

struct Student {
    char name[50];
    int age;
    float marks;
};

struct Student students[10]; // Array of 10 Student structures

2. Initialisation and Access:

students[0].age = 20; // Accessing and setting the age of the first Student

- Pointers to Structures allow you to refer to a structure using its address, which is efficient for memory management and function passing, also in 2 steps: Definition, Initialisation and Access. They are useful when passing structures to functions to avoid copying the entire structure, and managing dynamic data structures like linked lists, trees, etc...

1. Definition

struct Student {
    char name[50];
    int age;
    float marks;
};

struct Student *ptr; // Pointer to a Student structure

2. Initialisation and Access

struct Student s1;
ptr = &s1; // ptr now points to s1

// or dynamically allocate memory
ptr = (struct Student *)malloc(sizeof(struct Student));
Accessing Members: You use the -> operator to access members of the structure through the pointer.

ptr->age = 20; // Setting the age of the structure pointed to by ptr

- Combining arrays of structures with pointers to structures allows for flexible and efficient data management. For example, you can create an array of structures to store multiple items and use pointers to access and manipulate these structures dynamically. It gives an Array of Pointers to Structures, which is an array where each element is a pointer to a structure:

struct Student *studentArray[10]; // Array of 10 pointers to Student structures

// You can dynamically allocate memory for each structure and assign it to the array.
for (int i = 0; i < 10; ++i) {
    studentArray[i] = (struct Student *)malloc(sizeof(struct Student));
}

//You access and modify the structures through the array of pointers.
studentArray[0]->age = 20; // Setting the age of the first Student in the array

EX: Code with a structure representing books with attributes, an array of structures to store bookd, and pointers to structures for efficient manipulation of individual book entries. 

1.  #include <stdio.h>
2.  #include <stdlib.h> // for malloc and free
3.  // Define a structure for books
4.  struct Book {
5.  char title[100];
6.  char author[50];
7.  float price;
8.  };
9.  int main() {
10. int num_books;
11. printf("Enter the number of books: ");
12. scanf("%d", &num_books);
13. // Declare an array of structures
14. struct Book *library = (struct Book *)malloc(num_books * sizeof(struct Book));
15. if (library == NULL) {
16. printf("Memory allocation failed\n");
17. return 1;
18. }
19. // Input details of each book
20. for (int i = 0; i < num_books; ++i) {
21. printf("\nEnter details for book %d:\n", i + 1);
22. printf("Title: ");
23. scanf(" %[^\n]", library[i].title); // read until newline
24. printf("Author: ");
25. scanf(" %[^\n]", library[i].author); // read until newline
26. printf("Price: ");
27. scanf("%f", &library[i].price);
28. }
29. // Displaying details of each book using pointers to structures
30. printf("\nDetails of books:\n");
31. for (int i = 0; i < num_books; ++i) {
32. struct Book *ptr = &library[i]; // pointer to the current book structure
33. printf("Book %d:\n", i + 1);
34. printf("Title: %s\n", ptr->title);
35. printf("Author: %s\n", ptr->author);
36. printf("Price: %.2f\n", ptr->price);
37. }
38. // Free dynamically allocated memory
39. free(library);
40. return 0;
41. }

------------------------------------------------------------------------------------------------------------------------------
* Self-referential Structures

- They are structures that include a pointer to an instance of the same type. They exist because of quadratic time complexity, allowing for efficient insertion and searching with average-case time complexity of O(log n) for both operations, which is much better than the O(n) complexity.

- In simpler words, to reduce time resolution and prevent memory overuse, self structures are used like: Linked List, Doubly Linked  List, Binary Tree, Graph (Adjacency List Representation), N-ary Tree, Circular Linked List, and Skip List.

- EXAMPLES:

1. A linked list is a sequence of nodes where each node points to the next node in the sequence.

struct ListNode {
    int data;
    struct ListNode *next; // Pointer to the next node
};

2. A doubly linked list is a sequence of nodes where each node points to both the next node and the previous node.

struct DoublyListNode {
int data;
struct DoublyListNode *next;  // Pointer to the next node
struct DoublyListNode *prev;  // Pointer to the previous node
};

3. A binary tree is a tree data structure where each node has at most two children, referred to as the left child and the right child.

struct TreeNode {
int data;
struct TreeNode *left;  // Pointer to the left child
struct TreeNode *right; // Pointer to the right child
};

4. A binary search tree is a binary tree with the additional property that the left subtree of a node contains only nodes with keys less than the node’s key, and the right subtree contains only nodes with keys greater than the node’s key.

struct BSTNode {
int data;
struct BSTNode *left;  // Pointer to the left child
struct BSTNode *right; // Pointer to the right child
};

5. A trie is a tree-like data structure used to store a dynamic set of strings where the keys are usually strings. Each node has an array of pointers to child nodes.

#define ALPHABET_SIZE 26
struct TrieNode {
struct TrieNode *children[ALPHABET_SIZE]; // Array of pointers to child nodes
bool isEndOfWord; // True if the node represents the end of a word
};

6. In an adjacency list representation of a graph, each vertex has a list of pointers to its adjacent vertices.

struct GraphNode {
int vertex;
struct GraphNode *next; // Pointer to the next adjacent vertex
};
struct AdjList {
struct GraphNode *head; // Pointer to the head of the list
};
struct Graph {
int numVertices;
struct AdjList *array; // Array of adjacency lists
};

7. An N-ary tree is a tree in which a node can have at most N children.

#define N 3 // Maximum number of children for each node
struct NaryTreeNode {
int data;
struct NaryTreeNode *children[N]; // Array of pointers to children nodes
};

8. A circular linked list is a linked list where the last node points back to the first node, forming a circle.

struct CircularListNode {
int data;
struct CircularListNode *next; // Pointer to the next node, which eventually points back to the head
};

9. A skip list is a data structure that allows fast search within an ordered sequence of elements. It uses multiple levels of linked lists.

struct SkipListNode {
int data;
struct SkipListNode *next; // Pointer to the next node in the current level
struct SkipListNode *down; // Pointer to the node in the lower level
};

EX: Code showing how a binary tree works counting word occurrences in the text (This is a simple example. This example is simple.)

1.  #include <stdio.h>
2.  #include <stdlib.h>
3.  #include <string.h>
4.  #include <ctype.h>
5.  #define ALPHABET_SIZE 26
6.  // Trie node structure
7.  struct TrieNode {struct TrieNode* children[ALPHABET_SIZE];int isEndOfWord;int count;};
8.  // Function to create a new trie node

9.  struct TrieNode* createNode() {struct TrieNode* newNode = (struct TrieNode*)malloc(sizeof(struct TrieNode));newNode->isEndOfWord = 0;newNode->count = 0;for (int i = 0; i < ALPHABET_SIZE; i++) {newNode->children[i] = NULL;}return newNode;}

10. // Function to insert a word into the trie

11. void insert(struct TrieNode* root, const char* word) {struct TrieNode* pCrawl = root;while (*word) {int index = tolower(*word) - 'a';if (!pCrawl->children[index]) {pCrawl->children[index] = createNode();}pCrawl = pCrawl->children[index];word++;}pCrawl->isEndOfWord = 1;pCrawl->count++;}

12. // Function to search for a word in the trie and return its count

13. int search(struct TrieNode* root, const char* word) {struct TrieNode* pCrawl = root;while (*word) {int index = tolower(*word) - 'a';if (!pCrawl->children[index]) {return 0;}pCrawl = pCrawl->children[index];word++;}if (pCrawl->isEndOfWord) {return pCrawl->count;}return 0;}

14. // Function to delete the trie and free memory

15. void deleteTrie(struct TrieNode* root) {for (int i = 0; i < ALPHABET_SIZE; i++) {if (root->children[i]) {deleteTrie(root->children[i]);}}free(root);}

16. // Function to count the occurrences of words in a given text

17. void countWords(struct TrieNode* root, const char* text) {char word[256];int index = 0;while (*text) {if (isalpha(*text)) {word[index++] = tolower(*text);} else {if (index > 0) {word[index] = '\0';insert(root, word);index = 0;}}text++;}if (index > 0) {word[index] = '\0';insert(root, word);}}

18. int main() {struct TrieNode* root = createNode();char text[] = "This is a simple example. This example is simple.";countWords(root, text);char* words[] = {"this", "is", "simple", "example", "a"};for (int i = 0; i < sizeof(words)/sizeof(words[0]); i++) {printf("The word '%s' occurs %d times.\n", words[i], search(root, words[i]));}deleteTrie(root);return 0;}

------------------------------------------------------------------------------------------------------------------------------
* Table Lookup, and Typedef

- Table lookup is a technique used to replace runtime computation with a simpler array indexing operation. This method can improve performance by using pre-computed values stored in a table (an array). It is commonly used for operations that are repetitive and expensive to compute.

EX: Code converting an hexadecimal character to its decimal value

1.  #include <stdio.h>
2.  const int hexTable[256] = {
3.  ['0'] = 0, ['1'] = 1, ['2'] = 2, ['3'] = 3, ['4'] = 4, ['5'] = 5,
4.  ['6'] = 6, ['7'] = 7, ['8'] = 8, ['9'] = 9, 
5.  ['a'] = 10, ['b'] = 11, ['c'] = 12, ['d'] = 13, ['e'] = 14, ['f'] = 15,
6.  ['A'] = 10, ['B'] = 11, ['C'] = 12, ['D'] = 13, ['E'] = 14, ['F'] = 15
7.  };
9.  int hexValue(char c) {
10. return hexTable[(unsigned char)c];
11. }
12. int main() {
13. char c = 'A';
14. printf("The hexadecimal value of %c is %d\n", c, hexValue(c));
15. return 0;
16. }

- Typedef is a keyword used to create new type names (aliases) for existing types. This can make code more readable and easier to manage, especially with complex type definitions like structures, and function pointers.

EXAMPLES:

1. Simple Typedef: In this example, typedef is used to create a new type name ulong for unsigned long.

#include <stdio.h>
typedef unsigned long ulong;
int main() {
    ulong a = 1000000;
    printf("The value of a is %lu\n", a);
    return 0;
}

2. Typedef with Structures: here, typedef is used to create the alias Point for the struct definition, allowing us to declare variables of type Point without having to write struct Point every time.

#include <stdio.h>
typedef struct {
    int x;
    int y;
} Point;
int main() {
    Point p = {10, 20};
    printf("Point p: (%d, %d)\n", p.x, p.y);
    return 0;
}

3. Typedef with Function Pointers: here typedef is used to create the alias funcPtr for a function pointer type that points to functions taking an int parameter and returning void.

#include <stdio.h>
typedef void (*funcPtr)(int);
void myFunction(int a) {
    printf("Value: %d\n", a);
}
int main() {
    funcPtr f = myFunction;
    f(10); // Calling the function through the pointer
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------
* Union, and Bit-fields

- A union is a data structure that allows you to store different data types in the same memory location. The goal is that all members share the same memory, with only 1 member able to contain a value at any given time. This will come handy for situations where you want to use the same memory for different purposes at different times.

- Bit-fields allow the packing of data in a structure, enabling more efficient use of memory when you need to store multiple binary flags or small integers. You can specify the exact number of bits used for each field in the structure. They are commonly used in embedded systems or network protocols where memory is limited, and precise control over the data size is needed.

- The following code demonstrates the usage of a union and a structure with bit-fields. The union, named Data, is used to store different data types (integer, float, and string) in the same memory location, showcasing how the most recently assigned value is the one that can be accessed. 
The structure, named Flags, utilises bit-fields to efficiently store and manage small pieces of information, specifically whether a person is a student, an employee, and their age (ranging from 0 to 127). The program initialises and manipulates these structures and prints their values to the console.

EX: A code

1.  #include <stdio.h>
2.  #include <string.h>
3.  union Data {
4.  int i;
5.  float f;
6.  char str[20];
7.  };
8.  struct Flags {
9.  unsigned int isStudent : 1;
10. unsigned int isEmployee : 1;
11. unsigned int age : 7;
12. };
13. int main() {
14. union Data data;
15. data.i = 10;
16. printf("Union stores integer: %d\n", data.i);
17. data.f = 220.5;
18. printf("Union stores float: %f\n", data.f);
19. strcpy(data.str, "C Programming");
20. printf("Union stores string: %s\n", data.str);
21. struct Flags flags;
22. flags.isStudent = 1;
23. flags.isEmployee = 0;
24. flags.age = 25;
25. printf("Flags - isStudent: %d, isEmployee: %d, age: %d\n", flags.isStudent, flags.isEmployee, flags.age);
26. return 0;
27. }

##############################################################################################################################

I see you made it this far, good for u, you've almost got everything in C. Soon only experience, ingenuity, and willpower can differentiate you from experts:


⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⠶⠚⠛⠉⠉⠉⠀⠀⠉⠉⠙⠓⠦⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣾⣿⠴⠶⠦⢤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡿⠛⠛⠒⢦⡀⠀⠀⠉⠙⠳⢶⣤⣄⣀⣀⣀⣀⣀⣤⠜⢷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡏⠀⠀⠀⠀⠀⠹⣄⠀⠀⢀⠔⠋⠉⠉⠛⢍⠉⠉⣽⠃⠀⢀⣻⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⡤⢾⡇⠀⠀⣸⣧⠤⢤⣏⠉⠙⡏⠀⠀⢀⣀⠀⠈⣧⠴⣷⠶⠾⣿⡟⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠁⠀⠀⠹⣄⡼⠋⠀⠀⠀⠈⠁⠀⣧⠀⠀⠈⠁⠀⢠⡇⠀⠀⠀⠀⢻⠷⠛⣷⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠁⠀⠀⠀⠀⠀⠀⢳⡄⠀⠀⠀⠀⠀⠀⠈⠳⢄⣀⣀⠴⠋⠀⠀⠀⠀⠀⠀⠀⠀⠸⣇⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢠⡿⠀⠀⠀⠀⠀⠀⢀⡤⠀⠉⠓⠦⠤⠤⠖⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⡄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣼⠁⠀⠀⠀⠀⠀⠀⣨⠧⣄⣀⡀⠀⠀⠀⠀⠀⢀⣀⣠⡤⠶⠛⡧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣧⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠻⣤⣄⡈⠉⠉⠉⠉⠉⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⡀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣷⠀⠀⠀⠀⠀⠀⠀⠀⣴⠋⠉⠀⠀⠀⠀⠀⠀⠀⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⠀⠀⠀⠀⠀⠀⠀⢷⣄⠀⠀⣀⣄⠀⠀⠀⠀⢀⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⠉⠳⠦⠤⠴⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣧⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢠⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⠞⠁⢸⣇⡀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⠀⢻⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡴⠛⠁⠀⣰⠏⠉⠙⠳⢦⣄
⠀⠀⠀⠀⢀⣤⠞⠻⣆⠀⠙⢷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡤⠞⠉⠀⠀⣠⡾⠁⠀⠀⠀⠀⠀⠈
⠀⠀⣀⡴⠟⠁⠀⠀⠙⢧⡀⠀⠉⠻⢦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⠴⠖⠛⠉⠀⠀⢀⣤⠞⠉⠀⠀⠀⠀⠀⠀⠀⠀
⣤⠞⠋⠀⠀⠀⠀⠀⠀⠀⠻⣦⡀⠀⠀⠈⠛⢶⣄⠀⠀⠀⠀⠀⣀⣤⠴⠖⠛⠉⠁⠀⠀⠀⠀⣀⡤⠖⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⢀⣤⠶⢿⣧⠀⣠⣶⣯⣭⣀⠀⠀⠀⠀⠀⣀⣤⠴⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣷⠏⠀⢠⢬⣿⡿⠋⠁⠀⠀⠈⠙⣦⡴⠖⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⢙⣿⡟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠒⠂⠀⠀⠀⠀⠀⠀⡀⣀⣔


##############################################################################################################################

* 

* GUI Introduction and SDL2

- 

- To create a C program that opens a window and stays open until the user types return, we'll need to use a GUI library. One of the simplest and most widely-used libraries for creating windows in C is SDL (Simple DirectMedia Layer).

Here is how you can do this using the SDL library:

Install SDL if it's not already installed.
Write the C program that opens a window and waits for the user to press the return key.
Step 1: Install SDL
To install SDL on Ubuntu, you can use the following command:

sh
Copy code
sudo apt-get install libsdl2-dev
On macOS, you can use Homebrew:

sh
Copy code
brew install sdl2
On Windows, you need to download the development libraries from the SDL website and set them up in your development environment.
gcc -o sdl_program sdl_program.c -lSDL2


- Explanation
Initialisation: SDL_Init(SDL_INIT_VIDEO) initialises the SDL library for video.
Create Window: SDL_CreateWindow creates a window.
Create Renderer: SDL_CreateRenderer creates a renderer for the window.
Set Draw Color: SDL_SetRenderDrawColor sets the color used for drawing operations (in this case, blue).
Clear Window: SDL_RenderClear clears the window with the current drawing color.
Present Window: SDL_RenderPresent updates the window with the current rendering.
Event Loop: The program enters an infinite loop waiting for events. If the return key (SDLK_RETURN) is pressed, the program exits the loop and cleans up.

EX: Previous program in a GUI window where 
------------------------------------------------------------------------------------------------------------------------------






